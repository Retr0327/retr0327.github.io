{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    sup: \"sup\",\n    a: \"a\",\n    h2: \"h2\",\n    h3: \"h3\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    ul: \"ul\",\n    li: \"li\",\n    blockquote: \"blockquote\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h4: \"h4\",\n    ol: \"ol\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"ACID 原則是 RDBMS 中 transaction (資料庫交易)\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-1\",\n          id: \"user-content-fnref-1\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"1\"\n        })\n      }), \" 的特性，本篇我們將以 PostgreSQL 來當作例子。四個英文字母分別為\\nAtomicity (原子性)、Consistency (一致性)、Isolation (隔離性)、Durability (持續性)。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"atomicity-原子性\",\n      children: \"Atomicity (原子性)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"定義\",\n      children: \"定義\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"指的是一個 transaction 中的所有操作如果如果沒有錯誤，就全部 commit；反之，只要有一個錯誤（網路問題、當機等），就全部 rollback (回復)。\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-2\",\n          id: \"user-content-fnref-2\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"2\"\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"目的\",\n      children: \"目的\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"為了確保它資料庫中數據的「\", _jsx(_components.strong, {\n        children: \"一致性\"\n      }), \"」，因為我們不能保證在做資料更改的當下，資料庫不會遇上不可預期的錯誤。當資料庫重啟後，資料必須要是正確的，且不能有數據錯誤的問題產生。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"舉例\",\n      children: \"舉例\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"假設用戶 A 要匯錢給一個用戶 B：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sql\",\n        children: \"BEGIN;\\nUPDATE user SET balance = balance - amount WHERE username = 'UserA' AND balance >= amount;\\nUPDATE user SET balance = balance + amount WHERE username = 'UserB';\\nCOMMIT;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果沒有 Atomicity，當第一句的 \", _jsx(_components.code, {\n        children: \"UPDATE\"\n      }), \" 成功，而第二句的 \", _jsx(_components.code, {\n        children: \"UPDATE\"\n      }), \"失敗，會導致 \", _jsx(_components.code, {\n        children: \"UserA\"\n      }), \" 錢減少了，但\\n\", _jsx(_components.code, {\n        children: \"UserB\"\n      }), \" 的錢卻沒有相對應的增加。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此 Atomicity 保證資料庫的數據能夠從一個正確狀態直接移到下一個正確狀態。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"consistency-一致性\",\n      children: \"Consistency (一致性)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"定義-1\",\n      children: \"定義\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在 transaction 成功 commit 後，資料改動必須滿足 unique constraint 和用戶自定義 constraint，像是一些 FK\\n跟資料欄位型態的限制。只要沒有遵守，就全部 rollback。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"目的-1\",\n      children: \"目的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"確保資料庫中的數據滿足所有 unique constraint 和自定義的 constraint，並符合預期的業務規則。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"舉例-1\",\n      children: \"舉例\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sql\",\n        children: \"CREATE TABLE user (\\n    id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\\n    email TEXT NOT NULL UNIQUE\\n);\\n\\nINSERT INTO user (email) VALUES ('1@mail.com');\\nINSERT INTO user (email) VALUES ('1@mail.com');\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果沒有 Consistency，我們就會在 \", _jsx(_components.code, {\n        children: \"user\"\n      }), \" 中 \", _jsx(_components.code, {\n        children: \"INSERT\"\n      }), \"\\n重複的數據，可能會導致很多不可預期的錯誤，像是數據不一致或是數據超過開發者所設下的限制等等。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此 Consistency 保證資料庫數據的改動能夠遵守限制，transaction 才能成功 commit。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"isolation-隔離性\",\n      children: \"Isolation (隔離性)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"定義-2\",\n      children: \"定義\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"指的是多個 transactions 之間相互隔離，不能互相影響。Isolation 有分好幾種等級，以下是\", _jsx(_components.strong, {\n        children: \"由低到高\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"read uncommitted (讀取未提交數據): transaction 可以讀取其他 transactions 未提交的數據 → 可能會讀取到不一致的數據\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"read commited (讀取已提交數據): transaction 只能讀取已經提交的數據\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"repeatable read (可重複讀取): transaction 在開始時鎖定了讀取的數據，以防止其他交易修改\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"serializable (可序列化): transactions 之間是完全隔離的，它們之間不能有任何干擾\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在最低等級是會導致 race condition，最高等級則不會有，但是其效能會大幅度降低。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"有些帳戶操作的系統之所以慢，是因為需要高度隔離而使效能降低\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"目的-2\",\n      children: \"目的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"避免 race condition 的情況發生。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"舉例-2\",\n      children: \"舉例\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以用戶提款為例：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sql\",\n        children: \"-- session 1\\nBEGIN;\\nUPDATE user SET balance = balance - amount WHERE username = 'UserA' AND balance >= amount;\\nCOMMIT;\\n\\n-- session 2\\nBEGIN;\\nUPDATE user SET balance = balance + amount WHERE username = 'UserA';\\nCOMMIT;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果有 isolation 的 LOCK 機制，在 session 1 執行 \", _jsx(_components.code, {\n        children: \"UPDATE\"\n      }), \" 時，RDBMS 會為 \", _jsx(_components.code, {\n        children: \"UPDATE\"\n      }), \" 會影響的數據進行 Write\\nLock，也就是該 \", _jsx(_components.code, {\n        children: \"UserA\"\n      }), \" 的帳戶被凍結一樣，其他人不能對 \", _jsx(_components.code, {\n        children: \"UserA\"\n      }), \" 的帳戶進行匯款或提款等動作，也就是 session 2 會無法進行。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"durability-持續性\",\n      children: \"Durability (持續性)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"定義-3\",\n      children: \"定義\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要儲存硬體沒有受損，commited transaction 的數據會\", _jsx(_components.strong, {\n        children: \"永久\"\n      }), \"保存到磁碟上。為了確保資料的持久性，postgresql 使用了 Write-Ahead Logging (WAL)\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-3\",\n          id: \"user-content-fnref-3\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"3\"\n        })\n      }), \" 機制。這意味著在寫入數據之前，postgresql\\n會先將更改記錄到 WAL 檔案中，確保即使發生意外，資料仍然可以從 WAL 恢復。舉個例子，假設你有一個銀行帳戶，並且你想要從這個帳戶中存入\\n$100。當你執行存款操作時，WAL 會首先將這個操作記錄到日誌文件中，然後再將 $100 加到你的帳戶中。如果在這個過程中發生了任何問題，例如系統故障或停電，那麼可以使用日誌文件來恢復帳戶的狀態。WAL\\n的另一個優點是它可以實現資料庫的讀寫分離。因為 WAL 已經記錄了所有的更改，所以可以在寫入資料時讀取資料。這使得資料庫可以同時實現高效讀取和寫入。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"目的-3\",\n      children: \"目的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"確保 commited transaction 的數據將永久保存在資料庫中。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: _jsx(\"div\", {\n              style: {\n                width: 125\n              },\n              children: \"Atomicity (原子性)\"\n            })\n          }), _jsx(_components.th, {\n            children: _jsx(\"div\", {\n              style: {\n                width: 150\n              },\n              children: \"Consistency (一致性)\"\n            })\n          }), _jsx(_components.th, {\n            children: _jsx(\"div\", {\n              style: {\n                width: 125\n              },\n              children: \"Isolation (隔離性)\"\n            })\n          }), _jsx(_components.th, {\n            children: _jsx(\"div\", {\n              style: {\n                width: 125\n              },\n              children: \"Durability (持久性)\"\n            })\n          })]\n        })\n      }), _jsx(_components.tbody, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"確保數據的一致性\"\n          }), _jsx(_components.td, {\n            children: \"數據更改需滿足所有限制\"\n          }), _jsx(_components.td, {\n            children: \"避免 race condition\"\n          }), _jsx(_components.td, {\n            children: \"確保 commited transaction 的數據永久保存\"\n          })]\n        })\n      })]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.kennycoder.io/2020/01/21/RDBMS-%E9%97%9C%E8%81%AF%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB-ACID%E5%9F%BA%E7%A4%8E%E8%A7%80%E5%BF%B5/\",\n          children: \"RDBMS (關聯式資料庫) - ACID 基礎觀念\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://medium.com/appxtech/%E8%B3%87%E6%96%99%E5%BA%AB-%E6%B7%BA%E8%AB%87%E9%97%9C%E8%81%AF%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87acid%E7%89%B9%E6%80%A7-83a1b4178981\",\n          children: \"│ 資料庫 │ 淺談關聯式資料庫與 ACID 特性\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/TritonHo/slides\",\n          children: \"TritonHo slides\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://oldmo860617.medium.com/database-transaction-acid-156a3b75845e\",\n          children: \"Database Transaction & ACID\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Transaction (資料庫交易) 是 RDBMS 中一組一連串的操作（由各種資料庫語法 SELECT、INSERT 等所組成），且必須滿足 ACID 的特性。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-2\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"會叫「原子性」是因為在化學中，原子是最小且不可分割的結構。如同 RDBMS 中的 transaction 一樣，要麽全部 commit (確認)，要麼全部 rollback (回覆)。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-2\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-3\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Write-Ahead Logging (WAL) 是一種事務記錄方法，它會在寫入數據之前將更改記錄到一個日誌文件中。這樣可以確保即使發生系統故障，資料仍然可以從日誌文件中恢復 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-3\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},"headings":[{"depth":2,"value":"Atomicity (原子性)"},{"depth":3,"value":"定義"},{"depth":3,"value":"目的"},{"depth":3,"value":"舉例"},{"depth":2,"value":"Consistency (一致性)"},{"depth":3,"value":"定義"},{"depth":3,"value":"目的"},{"depth":3,"value":"舉例"},{"depth":2,"value":"Isolation (隔離性)"},{"depth":3,"value":"定義"},{"depth":3,"value":"目的"},{"depth":3,"value":"舉例"},{"depth":2,"value":"Durability (持續性)"},{"depth":3,"value":"定義"},{"depth":3,"value":"目的"},{"depth":2,"value":"總結"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"},"siblings":{"next":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"},"prev":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}}},"colorScheme":"light","__N_SSG":true}