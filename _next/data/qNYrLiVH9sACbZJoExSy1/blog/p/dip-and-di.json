{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    sup: \"sup\",\n    a: \"a\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    ol: \"ol\",\n    h4: \"h4\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"tl-dr\",\n      children: \"TL; DR\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Dependency injection (DI) 是一種實現 dependency inversion principle (DIP) 的技術，而 DIP 是一種設計原則\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-1\",\n          id: \"user-content-fnref-1\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"1\"\n        })\n      }), \"。\"]\n    }), \"\\n\", _jsx(\"div\", {\n      style: {\n        marginTop: -20,\n        marginBottom: -20\n      },\n      children: _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"https://www.tutorialsteacher.com/Content/images/ioc/principles-and-patterns.png\",\n          alt: \"di-dip-relationship\"\n        })\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"DIP 是一種「設計原則」，強調高階模組不應該依賴於低階模組\", _jsx(_components.sup, {\n          children: _jsx(_components.a, {\n            href: \"#user-content-fn-2\",\n            id: \"user-content-fnref-2\",\n            \"data-footnote-ref\": true,\n            \"aria-describedby\": \"footnote-label\",\n            children: \"2\"\n          })\n        }), \"，而是應該依賴於抽象。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DI：是「實現 DIP」的方法，將 dependency 通過「注入」的方式提供給需要的 class 或 function。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"依賴反轉原則-dependency-inversion-principle-dip\",\n      children: \"依賴反轉原則 (Dependency Inversion Principle, DIP)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"首先，為何要說「反轉」呢？更精確地說，\", _jsx(_components.strong, {\n        children: \"為何要反轉呢\"\n      }), \"？這是因為我們在開發的時候，往往都是讓大功能（高階模組）調用各個小功能（低階模組）來實現目標，但隨著層次越高，底下依賴的模組越多，所要改動的頻率就會提高。為了解耦 (decoupling)，DIP\\n提出了幾個重要的原則：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"使高階模組（呼叫者 caller）不再直接依賴低階模組（被呼叫者 callee），兩者都該依賴抽象\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"抽象不應該依賴於具體實作方式。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"具體實作方式則應該依賴抽象。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DIP 告訴開發者應該要把重點放在「功能」上，不應該用低階模組去拼湊出高階，而是應該用「抽象層 (abstract\\nclass、interface)」去隔開實作，解開高階與低階之間的耦合\\n(coupling)。\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"# 原本的關係\\n高階模組 → 低階模組\\n\\n# 反轉後\\n高階模組 → 介面 ← 低階模組\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"高階模組提出它需要的功能，低階模組去實作出這些功能、達成高階模組的目標，就好比「公司為了做好的網站（高階模組的目標）」，開出了「應徵條件（介面）」，而我們前去應徵（低階模組的實作）。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"講完一些專有名詞，我們用 Python 來實作看看：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"沒有使用 DIP：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"class PostgreSQL:\\n    def save(self, data: str) -> None:\\n        print(f\\\"{data} has been saved to PostgreSQL!\\\")\\n\\ndef main() -> None:\\n    pg = PostgreSQL()\\n    pg.save(\\\"1@mail.com\\\")\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"乍看之下這樣寫似乎沒有什麼問題，但哪天我們不想用 \", _jsx(_components.code, {\n            children: \"PostgreSQL\"\n          }), \" 類別而是想用 \", _jsx(_components.code, {\n            children: \"MongoDB\"\n          }), \" 類別呢？\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"class MongoDB:\\n    def save(self, data: str) -> None:\\n        print(f\\\"{data} has been saved to MongoDB!\\\")\\n\\ndef main() -> None:\\n    mongo = MongoDB()\\n    mongo.save(\\\"1@mail.com\\\")\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"如果一直換 database 種類，\", _jsx(_components.code, {\n            children: \"main()\"\n          }), \" 豈不是每次都要修改，把代碼給寫死不是一個好辦法，因為會產生預想不到的耦合 (coupling)。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"使用 DIP：\"\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"為了使 \", _jsx(_components.code, {\n            children: \"main()\"\n          }), \" 不再直接與 \", _jsx(_components.code, {\n            children: \"PostgreSQL\"\n          }), \" 類別耦合 (coupling)，我們需要一個介面 (interface) 或抽象類別 (abstract\\nclass)：\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"from abc import ABC, abstractmethod\\n\\nclass Database(ABC):\\n    @abstractmethod\\n    def save(self, data: str) -> None:\\n        pass\\n\\nclass PostgreSQL:\\n    def save(self, data: str) -> None:\\n        print(f\\\"{data} has been saved to PostgreSQL!\\\")\\n\\ndef main() -> None:\\n    pg = PostgreSQL()\\n    pg.save(\\\"1@mail.com\\\")\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"這樣就實現了 DIP，主程式不再直接與 \", _jsx(_components.code, {\n            children: \"PostgreSQL\"\n          }), \" 類別耦合。如果你需要更換資料存儲方式，只需要實現一個新的類別並實現\\n\", _jsx(_components.code, {\n            children: \"Database\"\n          }), \" 抽象類別即可。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"到這裡，不知道你有沒有發現什麼問題？我們在使用 \", _jsx(_components.code, {\n        children: \"Database\"\n      }), \" 功能之前，還是得先建立該類別的 instance (實例)，也就是\\n\", _jsx(_components.code, {\n        children: \"pg = PostgreSQL()\"\n      }), \"，這樣豈不是直接依賴了 \", _jsx(_components.code, {\n        children: \"PostgreSQL\"\n      }), \" 嗎？「依賴關係」是反轉了，但是還是要有 instance (實例)\\n才能使用。也就是說，這違反了 SOLID 中的 I (Interface Segregation Principle)。\", _jsx(_components.code, {\n        children: \"main()\"\n      }), \" 不應知道具體的 instance\\nclass (實作類別) 是誰，具體的實作 應是可「替換」的。將對具體的依賴更改為對抽象的依賴，仍然是不夠的。面對這種問題，程式大老們提出了許多個解決的方法，其中一個就是\\ndependency injection (依賴注入)。\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"[Arjan from ArjanCodes]Without dependency injection, there is no dependency inversion principle.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"依賴注入-dependency-injection-di\",\n      children: \"依賴注入 (Dependency Injection, DI)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DI 指的是用各種方法把「低階模組」丟到「高階模組」裡。它將物件之間的依賴關係轉移到「創建物件」的地方。它的目的是為了減少耦合性，使得系統更加靈活和可維護。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們依舊用 database 的例子來實作 DI：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"from abc import ABC, abstractmethod\\n\\nclass Database(ABC):\\n    @abstractmethod\\n    def save(self, data: str) -> None:\\n        pass\\n\\nclass PostgreSQL(Database):\\n    def save(self, data: str) -> None:\\n        print(f\\\"{data} has been saved to PostgreSQL!\\\")\\n\\nclass MongoDB(Database):\\n    def save(self, data: str) -> None:\\n        print(f\\\"{data} has been saved to MongoDB!\\\")\\n\\nclass UserService:\\n    def __init__(self, db: Database) -> None:\\n        self.db = db\\n\\n    def save_user(self, email: str):\\n        self.db.save(email)\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在這個例子中，我們利用建構式 \", _jsx(_components.code, {\n        children: \"__init__\"\n      }), \" 的方式，從外部傳入 \", _jsx(_components.code, {\n        children: \"Database\"\n      }), \"\\n抽象類別的實體來使用。我們再也不用為了換 database 而改變代碼，也不用因為實作細節或是方法名稱而煩惱，只要照 \", _jsx(_components.code, {\n        children: \"Database\"\n      }), \" 使用就可以了。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"def main():\\n    pg = PostgreSQL()\\n    user = UserService(pg)\\n    user.save_user(\\\"1@mail.com\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-python\",\n            children: \"def main():\\n    mongo = MongoDB()\\n    user = UserService(mongo)\\n    user.save_user(\\\"1@mail.com\\\")\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"至於要傳遞哪個 instance 進來，這份工作要交給開發者或當下的情境，就讓身為控制中心的 \", _jsx(_components.code, {\n        children: \"main()\"\n      }), \" 去決定，大家各司其職，落實\\nSOLID 中的 S (Single Responsibility)。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其實 DIP 與 DI 之間的關係是有\", _jsx(_components.strong, {\n        children: \"先後順序\"\n      }), \"的：\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"DIP 告訴我們依賴的對象應該是「功能」\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"高階模組不應該依賴於低階模組，兩者都應該依賴抽象\"\n            }), \"：用 interface (介面) 或 abstract class (抽象類) 來進行隔離。\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [_jsx(_components.strong, {\n              children: \"抽象不應該依賴細節。細節應該依賴抽象\"\n            }), \"：interface (介面) 或 abstract class (抽象類) 應該是高階模組提出的要求，然後才去使用實作了這些要求的低階模組。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"為了解決介面實例化仍然會產生依賴的問題，為了解決就有了像是 dependency injection (DI) 等方法\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DI：藉由從「建構式傳遞」等方式，把低階模組交給高階模組使用者\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://lotabout.me/2018/Dependency-Inversion-Principle/\",\n          children: \"DIP vs IoC vs DI\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://igouist.github.io/post/2020/12/oo-14-dependency-inversion-principle/\",\n          children: \"菜雞與物件導向 (14): 依賴反轉原則\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://notfalse.net/1/dip\",\n          children: \"依賴反向原則 (Dependency-Inversion Principle, DIP)\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=2ejbLVkCndI&t=125s\",\n          children: \"Dependency INVERSION vs dependency INJECTION in Python\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"SOLID 中的 D 就是 dependency inversion。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-2\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"高階與低階，指的是「相對關係」，也就是「呼叫者 (caller)」與「被呼叫者 (callee)」之間的關係。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-2\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-01-28","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},"headings":[{"depth":2,"value":"TL; DR"},{"depth":2,"value":"依賴反轉原則 (Dependency Inversion Principle, DIP)"},{"depth":2,"value":"依賴注入 (Dependency Injection, DI)"},{"depth":2,"value":"總結"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-01-28","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-01-28","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"},"siblings":{"next":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"},"prev":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}}},"colorScheme":"light","__N_SSG":true}