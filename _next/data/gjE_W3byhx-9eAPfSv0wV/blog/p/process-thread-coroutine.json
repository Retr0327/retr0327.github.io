{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    sup: \"sup\",\n    a: \"a\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\",\n    blockquote: \"blockquote\",\n    strong: \"strong\",\n    pre: \"pre\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h4: \"h4\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"網路上有一張圖就可以讓我們快速明白他們之間的差別：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://blog.kennycoder.io/2020/05/16/%E9%80%B2%E7%A8%8B-Process-%E3%80%81%E7%B7%9A%E7%A8%8B-Thread-%E3%80%81%E5%8D%94%E7%A8%8B-Coroutine-%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AC%9B%E8%A7%A3/cover.png?pt=25\",\n        alt: \"summary\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"process-進程\",\n      children: \"Process (進程)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"指的是在 OS (Operating System) 上執行的一個基本單位\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-1\",\n          id: \"user-content-fnref-1\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"1\"\n        })\n      }), \"，當執行一個 program/application 時，OS 會分配記憶體和\\nCPU 資源給該 program/application。當我們打開 mac 的 Activity Monitor (活動監控) 或 windows\\n的工作管理員，就可以看多很多 processes：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://i.imgur.com/r1x96fi.png?w=800\",\n        alt: \"process-mac\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"每次執行程式時，系統都會創建一個新的 process，它代表著程式正在運行的狀態，並且「不會影響其他程式的運行」（如果可以任意呼叫其他應用程式的內容，可能會爆炸吧），也因此他有以下優缺點：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"優點：\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"每個 process 都擁有獨立的系統資源，且不容易相互影響\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"因為獨立，所以不用作 locking 機制\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"缺點：\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"每建立一個 process，OS 都要 allocate 資源給它\"\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"如果 processes 之間要溝通，建立 context switching (上下文交換) \", _jsx(_components.sup, {\n              children: _jsx(_components.a, {\n                href: \"#user-content-fn-2\",\n                id: \"user-content-fnref-2\",\n                \"data-footnote-ref\": true,\n                \"aria-describedby\": \"footnote-label\",\n                children: \"2\"\n              })\n            }), \"的 overhead 較大，因為涉及到 OS 資源的切換\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"thread-線程\",\n      children: \"Thread (線程)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://microcontrollerslab.com/wp-content/uploads/2019/08/process-and-program.png?pt=6&pb=70&w=450\",\n        alt: \"sd\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"又稱「light weight process」，為 process 內部的執行單元，也就是說一個 process 由至少一個 thread\\n所組成的。與 process 不一樣的地方在於，由於 threads 彼此之間共享 process 的記憶體空間和其他資源（不是獨立擁有），因此\\nthread 在做 context switching 時的 overhead 比 process 還要小。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"parallelism-並行-vs-concurrency-並發\",\n      children: \"Parallelism (並行) vs. Concurrency (並發)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://www.dotnetcurry.com/images/dotnetcore/concurrent/parallel-vs-concurrent-dotnet-core.png?pt=105&pb=50\",\n        alt: \"parallelism vs. concurrency\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由圖可知，Concurrency 其實就是在多個 tasks 共用「同一個 CPU」時，每個 task 輪流使用該 CPU 的資源，也就是在某個時間點，只會有一個\\ntask 在 CPU 上執行；而 Parallelism 是指多個 CPU 同時執行各自的任務，且不需要 context switching，因此不會出現多個任務搶佔同個\\nCPU 的情況。\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"如果電腦只有單核，就只能做到 Concurrency。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由於現在的電腦大多都配備多核心，所以才可以達到 parallel，讓我們感受到電腦速度比以往來得快上許多。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"coroutine-協程\",\n      children: \"Coroutine (協程)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"作為一種「輕量級」\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-3\",\n          id: \"user-content-fnref-3\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"3\"\n        })\n      }), \"的線程，一個 thread 可以存在多個 coroutines，而 coroutine 也會有自己的 registers、context、stack\\n等等。與 process 和 thread 不同，coroutine 的調度由「\", _jsx(_components.strong, {\n        children: \"用戶\"\n      }), \"」而非 CPU 進行，並且只能進行「非搶佔式」的調度。「非搶佔式調度」是指當一個 coroutine 被 block 住時，將不會影響其他 coroutines 的執行，因此不用像 thread 或 process 要進行搶佔式調度，而是由開發者去控制\\ncoroutine 的切換。如此一來，資源就可以有效地被利用，以達到 concurrency 的概念（因為在同一個 CPU）。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們以 Python 的 asyncio 為例：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python\",\n        children: \"import asyncio\\n\\nasync def coroutine_1():\\n    print(\\\"coroutine 1 started\\\")\\n    await asyncio.sleep(3)\\n    print(\\\"coroutine 1 finished\\\")\\n\\nasync def coroutine_2():\\n    print(\\\"coroutine 2 started\\\")\\n    await asyncio.sleep(1)\\n    print(\\\"coroutine 2 finished\\\")\\n\\nasync def main():\\n    print(\\\"main started\\\")\\n    task1 = asyncio.create_task(coroutine_1())\\n    task2 = asyncio.create_task(coroutine_2())\\n    await task1\\n    await task2\\n    print(\\\"main finished\\\")\\n\\nasyncio.run(main())\\n\\n# main started\\n# coroutine 1 started\\n# coroutine 2 started\\n# coroutine 2 finished\\n# coroutine 1 finished\\n# main finished\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"當 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \" 執行 \", _jsx(_components.code, {\n        children: \"await asyncio.sleep(3)\"\n      }), \" 的時候，它會主動放棄 CPU，等待 3 秒鐘後再繼續執行。在這段時間內，CPU\\n被切換到執行 \", _jsx(_components.code, {\n        children: \"coroutine_2\"\n      }), \"。當 \", _jsx(_components.code, {\n        children: \"coroutine_2\"\n      }), \" 執行 \", _jsx(_components.code, {\n        children: \"await asyncio.sleep(1)\"\n      }), \" 時，它也會主動放棄\\nCPU，等待 1 秒鐘後再繼續執行。這時 Python 會回到 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \" 看它是否已經睡完 3 秒，由於 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \" 還沒有睡完\\n3 秒，所以 Python 又會切換到執行 \", _jsx(_components.code, {\n        children: \"coroutine_2\"\n      }), \"，直到 \", _jsx(_components.code, {\n        children: \"coroutine_2\"\n      }), \" 完成後再回到 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \"。當 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \"\\n睡完 3 秒後，Python 會再次切換到 \", _jsx(_components.code, {\n        children: \"coroutine_1\"\n      }), \"，讓它繼續執行，最後再印出 \", _jsx(_components.code, {\n        children: \"\\\"coroutine 1 finished\\\"\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {}), _jsx(_components.th, {\n            children: \"Process\"\n          }), _jsx(_components.th, {\n            children: \"Thread\"\n          }), _jsx(_components.th, {\n            children: \"Coroutine\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Resource Utilization\"\n          }), _jsx(_components.td, {\n            children: \"heavy\"\n          }), _jsx(_components.td, {\n            children: \"light\"\n          }), _jsx(_components.td, {\n            children: \"lightest\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Scheduling\"\n          }), _jsx(_components.td, {\n            children: \"OS-driven\"\n          }), _jsx(_components.td, {\n            children: \"OS-driven\"\n          }), _jsx(_components.td, {\n            children: \"user-driven\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Context Switching Overhead\"\n          }), _jsx(_components.td, {\n            children: \"high\"\n          }), _jsx(_components.td, {\n            children: \"low\"\n          }), _jsx(_components.td, {\n            children: \"lower\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Address Space\"\n          }), _jsx(_components.td, {\n            children: \"separate\"\n          }), _jsx(_components.td, {\n            children: \"shared\"\n          }), _jsx(_components.td, {\n            children: \"shared\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Stack Size\"\n          }), _jsx(_components.td, {\n            children: \"large\"\n          }), _jsx(_components.td, {\n            children: \"small\"\n          }), _jsx(_components.td, {\n            children: \"smaller\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.kennycoder.io/2020/05/16/%E9%80%B2%E7%A8%8B-Process-%E3%80%81%E7%B7%9A%E7%A8%8B-Thread-%E3%80%81%E5%8D%94%E7%A8%8B-Coroutine-%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AC%9B%E8%A7%A3/\",\n          children: \"進程 (Process)、線程 (Thread)、協程 (Coroutine) 的概念講解\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://ithelp.ithome.com.tw/articles/10239629\",\n          children: \"Day 18 | Kotlin 中處理異步的好伙伴 - Coroutine\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.tomchen.me/2020/03/21/OS/%5BOS%5D%20%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98-Process/\",\n          children: \"[OS] 作業系統筆記-Process\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"實際上一個 CPU 在執行時只能同時運用一個 process，只是 CPU 可以快速地在多個 processes 之間進行切換，使多個 process 模擬同時執行的情況 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-2\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Context switching (上下文交換) 是指在執行多個 tasks 時，切換不同 tasks 的狀態信息。當 CPU 需要切換到另一個 task\\n時，它必須保存當前正在運行的 task 的狀態（例如記憶體位置），並且加載下一個要執行的 task 的狀態 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-2\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-3\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"輕量級一詞來自於 coroutine 相對於 thread 和 process 而言的資源需求較少，特別是在內存消耗、創建/銷毀時間、和 context\\nswitching 的時間方面 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-3\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","updatedAt":"2023-02-16","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZtUEVEgktTP4LPE.png"}},"headings":[{"depth":2,"value":"Process (進程)"},{"depth":2,"value":"Thread (線程)"},{"depth":2,"value":"Parallelism (並行) vs. Concurrency (並發)"},{"depth":2,"value":"Coroutine (協程)"},{"depth":2,"value":"總結"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","updatedAt":"2023-02-16","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZtUEVEgktTP4LPE.png"}},{"frontMatter":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","updatedAt":"2023-02-16","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZtUEVEgktTP4LPE.png"},"siblings":{"next":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"},"prev":null}},"colorScheme":"light","__N_SSG":true}