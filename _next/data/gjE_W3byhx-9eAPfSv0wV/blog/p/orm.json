{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    a: \"a\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\",\n    strong: \"strong\",\n    sup: \"sup\",\n    blockquote: \"blockquote\",\n    del: \"del\",\n    h4: \"h4\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"orm-object-relational-mapping\",\n      children: \"ORM (Object-Relational Mapping)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"ORM 主要是將 OOP (Object Oriented Programming) 的概念與 database 中 table\\n的概念對應起來。舉例來說，我定義一個物件類別 \", _jsx(_components.code, {\n        children: \"User\"\n      }), \"，那該物件就對應一個 table，也就是 \", _jsx(_components.code, {\n        children: \"users\"\n      }), \"；我們通過建立 \", _jsx(_components.code, {\n        children: \"User\"\n      }), \"\\n類別的實例（instance）來對應 table 中的某筆記錄。我們以 \", _jsx(_components.a, {\n        href: \"https://www.prisma.io/\",\n        children: \"Prisma\"\n      }), \" 和 PostgreSQL 為例：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我們在 \", _jsx(_components.code, {\n        children: \"prisma.schema\"\n      }), \" 中定義一個 \", _jsx(_components.code, {\n        children: \"User\"\n      }), \" model：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sql\",\n        children: \"model User {\\n  uid         String     @id @default(uuid()) @db.Uuid\\n  email       String     @unique\\n  firstName   String     @map(\\\"first_name\\\")\\n  lastName    String     @map(\\\"last_name\\\")\\n\\n  @@map(\\\"users\\\")\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"User\"\n      }), \" 在 就代表 PostgreSQL 中的 \", _jsx(_components.code, {\n        children: \"users\"\n      }), \" table：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-text\",\n        children: \" uid | email | first_name | last_name |\\n----+-------+------------+------------\\n    |       |            |           |\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"而我們建立 \", _jsx(_components.code, {\n        children: \"User\"\n      }), \" 的實例就對應 database 的某一條紀錄：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-javascript\",\n        children: \"import { PrismaClient } from '@prisma/client';\\n\\nconst prisma = new PrismaClient();\\n\\nconst result = await prisma.user.findUnique({\\n  where: {\\n    uid: 'af7c1fe6-d669-414e-b066-e9733f0de7a8',\\n  },\\n});\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"優點\",\n      children: \"優點\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"安全性 - SQL injection\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"如果是自己手寫 SQL 語句，你不知道自己啥時會犯蠢寫出一些會讓自己被 SQL injection 的句子，例如：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-javascript\",\n            children: \"const query = `SELECT * FROM users WHERE email = ${email} AND password = ${password}`;\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"如果有人手賤在 \", _jsx(_components.code, {\n            children: \"password\"\n          }), \" 輸入：\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-sql\",\n            children: \"' OR 1 = 1 --'\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"我們會得到：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-sql\",\n            children: \"SELECT * FROM users WHERE email = '1@mail.com' AND password = '' OR 1 = 1 --'\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"如果被 inject 的 SQL 語句包含 DELETE，那大工程師就要切腹謝罪了。但如果是透過 ORM 的方式，ORM\\n就會幫我們過濾掉這些惡意的 SQL 語句。\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"簡化性\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"ORM 可以避免工程師在寫 SQL 語句時犯蠢，ORM 讓我們用 OOP 的方式來做 CRUD\", _jsx(_components.sup, {\n            children: _jsx(_components.a, {\n              href: \"#user-content-fn-1\",\n              id: \"user-content-fnref-1\",\n              \"data-footnote-ref\": true,\n              \"aria-describedby\": \"footnote-label\",\n              children: \"1\"\n            })\n          }), \"，不僅簡化程式碼也提高了 readability (可讀性)。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"通用性\"\n          }), \"：\"]\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"ORM 讓 SQL 語句不會因為不同的工程師而有所不同，提高了 maintainability (可維護性)。例如以下兩句在 PostgreSQL 其實是會產生相同的結果：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-sql\",\n            children: \"-- sql query 1\\nSELECT * FROM users LIMIT 2;\\n\\n-- sql query 2\\nSELECT * FROM users FETCH FIRST 2 ROWS ONLY;\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"但對 ORM 來說只會是：\"\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-javascript\",\n            children: \"const result = await prisma.user.findMany({\\n  take: 2,\\n});\\n\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"缺點\",\n      children: \"缺點\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"效能 - N+1\"\n          }), \"：\"]\n        }), \"\\n\", _jsxs(_components.blockquote, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"在 N 次迴圈中，每次迭代都呼叫資料庫，因而拖慢速度\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"白話文就是在一個操作中，我們不小心「多次」訪問 database 而不是僅靠單一 query 來完成。舉例來說，我們有 \", _jsx(_components.code, {\n            children: \"User\"\n          }), \"\\n和 \", _jsx(_components.code, {\n            children: \"Post\"\n          }), \" 兩個 model，且 \", _jsx(_components.code, {\n            children: \"User\"\n          }), \" 和 \", _jsx(_components.code, {\n            children: \"Post\"\n          }), \" 是 one-to-many (一對多)：\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-sql\",\n            children: \" model User {\\n   uid     String     @id @default(uuid()) @db.Uuid\\n   name    String\\n   post    Post[] @relation(\\\"postsToUsers\\\")\\n\\n   @@map(\\\"users\\\")\\n}\\n\\nmodel Post {\\n  userUid   String   @map(\\\"user_uid\\\") @db.Uuid\\n  title String\\n  content String\\n\\n  user User @relation(\\\"postsToUsers\\\", fields: [userUid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: \\\"fkey_users\\\")\\n  @@map(\\\"posts\\\")\\n}\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"假設我們今天想要將所有的使用者的文章標題和內容呈現給大家看，「最直觀」\", _jsx(_components.del, {\n            children: \"同時也是我還是初學者犯過的錯\"\n          }), \"的做法如下：\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-javascript\",\n            children: \"const users = await prisma.user.findMany(); // 尚未執行 SQL 語句\\n\\nfor (const user of users) {    // 執行 SELECT * FROM users\\n  const posts = await prisma.post.findMany({   // 執行 SELECT * FROM posts\\n    where: {\\n      userUid: user.uid, // 執行 SELECT * FROM users WHERE uid = posts.user_uid\\n    },\\n  });\\n  console.log(posts);\\n}\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"那為什麼要叫 N+1 呢？我們先從 N+1 中的「1」說起，這個 1 是來自迴圈呼叫 \", _jsx(_components.code, {\n            children: \"users\"\n          }), \" 而來的；至於 N\\n則是來自迴圈的 O(n) 特性，如果我們有 10 筆資料就要 loop over 10 times。\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"其實也不是沒有解法，現在不同的 ORM 基本都提供一些解套方案，例如在 prisma 中可以在 \", _jsx(_components.code, {\n            children: \"findMany()\"\n          }), \" 時使用 \", _jsx(_components.code, {\n            children: \"include\"\n          }), \"：\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-javascript\",\n            children: \"const userPosts = await prisma.user.findMany({\\n  include: {\\n    posts: true,\\n  },\\n});\\n\\nfor (const user of userPosts) {\\n  console.log(user.posts);\\n}\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.code, {\n            children: \"include\"\n          }), \" 預先加載了所有 posts，就可以避免在迴圈中被多次呼叫。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"學習曲線高\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"複雜查詢維護性低\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://medium.com/johnliu-%E7%9A%84%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E6%80%9D%E7%B6%AD/%E5%BE%8C%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A0%82%E8%AA%B2-20-%E7%8F%BE%E4%BB%A3%E7%B3%BB%E7%B5%B1%E8%B3%87%E6%96%99%E5%B7%A5%E5%85%B7-orm-359da9a1d14a\",\n          children: \"後端工程師的第一堂課 (20) : 現代系統資料工具 — ORM\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://zhuanlan.zhihu.com/p/27323883\",\n          children: \"[科普文]什么是 ORM 中的 N+1\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.kennycoder.io/2020/01/09/SQL-injection-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9%E8%88%87%E9%98%B2%E7%AF%84%E6%95%99%E5%AD%B8-%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%B5%95%E4%B8%8D%E8%83%BD%E7%8A%AF%E7%9A%84%E4%BD%8E%E7%B4%9A%E9%8C%AF%E8%AA%A4/\",\n          children: \"SQL injection 原理介紹與防範教學 - 工程師絕不能犯的低級錯誤！\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://ithelp.ithome.com.tw/articles/10223194\",\n          children: \"[Day 15] 效能殺手 N+1 Query\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"CRUD 是由 create、read (get)、update、delete 的開頭字母組成，是我們常對資料庫做的四個動作 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},"headings":[{"depth":2,"value":"ORM (Object-Relational Mapping)"},{"depth":3,"value":"優點"},{"depth":3,"value":"缺點"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","updatedAt":"2023-02-16","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZtUEVEgktTP4LPE.png"}},{"frontMatter":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"},"siblings":{"next":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"},"prev":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}}},"colorScheme":"light","__N_SSG":true}