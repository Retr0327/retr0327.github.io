{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    h3: \"h3\",\n    code: \"code\",\n    pre: \"pre\",\n    img: \"img\",\n    sup: \"sup\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    h4: \"h4\",\n    ol: \"ol\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"npm\",\n      children: \"NPM\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"雖然 npm 允許開發人員可以輕鬆地管理和安裝 node modules。但是，它也有一些缺點，我們分成兩大時期來看：\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"v1v2---dependency-hell-依賴地獄\",\n      children: \"v1/v2 - Dependency Hell (依賴地獄)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"npm v1/v2 是使用了相對簡單的「嵌套式」\", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 結構，也就是 dependencies (依賴) 還會有自己的 dependencies。\\n設想一個情境，我們安裝了 A 和 C modules，而 A 和 C 剛好依賴不同版本的 B modules。這時候的 node_modules 會是這樣：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"node_modules\\n├── A@1.0.0\\n│   └── node_modules\\n│       └── B@1.0.0\\n└── C@1.0.0\\n    └── node_modules\\n        └── B@2.0.0\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果後來新增的 D 也是依賴 B@1.0.0，此時生成的 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 目錄便會如下所示：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"node_modules\\n├── A@1.0.0\\n│   └── node_modules\\n│       └── B@1.0.0\\n├── C@1.0.0\\n│   └── node_modules\\n│       └── B@2.0.0\\n└── D@1.0.0\\n    └── node_modules\\n        └── B@1.0.0\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以看到 B@1.0.0 重複安裝了兩遍，造成不必要的空間浪費，這就是「依賴地獄（Dependency Hell）」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://preview.redd.it/tfugj4n3l6ez.png?auto=webp&s=b8163176d8482d5e78ac631e16b7973a52e3b188\",\n        alt: \"dependency-hell\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"v3---phantom-dependency-幽靈依賴doppelgangers-多重依賴non-determinism-不確定性\",\n      children: \"v3 - Phantom dependency (幽靈依賴)、Doppelgangers (多重依賴)、Non-Determinism (不確定性)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"為了解決 dependency hell 的問題，npm v3 採用了「扁平化」設計\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-1\",\n          id: \"user-content-fnref-1\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"1\"\n        })\n      }), \"，將所有 dependencies 安裝在 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 的頂層目錄下，而不是在各自的子目錄中。\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-bash\",\n        children: \"node_modules\\n├── A@1.0.0\\n├── B@1.0.0\\n└── C@1.0.0\\n    └── node_modules\\n        └── B@2.0.0\\n├── D@1.0.0\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"可以看到 A 和 D 的子依賴的 B@1.0.0 不再放在他們各自底下的 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \"，而是與他們同層級，而 C 依賴的 B@2.0.0\\n則因爲版本原因還是嵌套在 C 的 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 下。扁平化的模式解決了依賴地獄的問題，但也帶來了額外的新問題。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"Phantom dependency (幽靈依賴)\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"雖然我們只安裝 A、C 和 D，但因為 npm v3 的特性也會將 B@1.0.0 \", _jsx(_components.strong, {\n            children: \"平鋪\"\n          }), \"到 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 下\", _jsx(_components.sup, {\n            children: _jsx(_components.a, {\n              href: \"#user-content-fn-2\",\n              id: \"user-content-fnref-2\",\n              \"data-footnote-ref\": true,\n              \"aria-describedby\": \"footnote-label\",\n              children: \"2\"\n            })\n          }), \"，\"]\n        }), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            children: \"{\\n    \\\"dependencies\\\": {\\n        \\\"A\\\": \\\"^1.0.0\\\",\\n        \\\"C\\\": \\\"^1.0.0\\\"\\n    }\\n}\\n\"\n          })\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"但這樣會導致意想不到的問題，例如某天 A 不在依賴 B 或是 B 的版本更新了，那麼就會造成依賴缺失或兼容性問題，導致專案在運行時會立刻報錯。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Doppelgangers (多重依賴)\"\n          }), \"\\n假設我們新安裝一個依賴 B@2.0.0 的 E：\"]\n        }), \"\\n\", _jsxs(_components.table, {\n          children: [_jsx(_components.thead, {\n            children: _jsxs(_components.tr, {\n              children: [_jsx(_components.th, {\n                children: \"B@1.0.0\"\n              }), _jsx(_components.th, {\n                children: \"B@2.0.0\"\n              })]\n            })\n          }), _jsx(_components.tbody, {\n            children: _jsxs(_components.tr, {\n              children: [_jsx(_components.td, {\n                children: \"A、D\"\n              }), _jsx(_components.td, {\n                children: \"C、E\"\n              })]\n            })\n          })]\n        }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(_components.pre, {\n          children: _jsx(_components.code, {\n            className: \"language-bash\",\n            children: \" node_modules\\n  ├── A@1.0.0\\n  ├── B@1.0.0\\n  ├── D@1.0.0\\n  ├── C@1.0.0\\n  │   └── node_modules\\n  │       └── B@2.0.0\\n  └── E@1.0.0\\n      └── node_modules\\n          └── B@2.0.0\\n\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"可以看到 B@2.0.0 被安裝了 2 次。無論是讓 B@1.0.0 還是 B@2.0.0 提升放到 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 的頂層，都會使另一個版本重複存在。這樣可能會產\\n生一些問題，像是版本重複可能會導致全局的 types 命名出現衝突，雖然各個 package 的代碼不會相互污染，但是他們的 types 仍然可以相互影響。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Non-Determinism (不確定性)\"\n          }), _jsx(_components.sup, {\n            children: _jsx(_components.a, {\n              href: \"#user-content-fn-3\",\n              id: \"user-content-fnref-3\",\n              \"data-footnote-ref\": true,\n              \"aria-describedby\": \"footnote-label\",\n              children: \"3\"\n            })\n          })]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"npm v3 會導致 node_modules 目錄結構不一定在每一次的下載後都是一致的，目錄及依賴樹結構會取決於開發者的「安裝的順序」。例如在 A 依賴 B@1.0.0，C 依賴 B@2.0.0 的情境中\\n，安裝後究竟應該提升 B 的 1.0.0 還是 2.0.0 到 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 的頂層？\"]\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsx(_components.p, {\n              children: \"情境 1\"\n            }), \"\\n\", _jsx(_components.pre, {\n              children: _jsx(_components.code, {\n                className: \"language-bash\",\n                children: \"node_modules\\n ├── A@1.0.0\\n ├── B@1.0.0\\n └── C@1.0.0\\n    └── node_modules\\n      └── B@2.0.0\\n\"\n              })\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsx(_components.p, {\n              children: \"情境 2\"\n            }), \"\\n\", _jsx(_components.pre, {\n              children: _jsx(_components.code, {\n                className: \"language-bash\",\n                children: \"node_modules\\n ├── A@1.0.0\\n │   └── node_modules\\n │      └── B@1.0.0\\n ├── B@2.0.0\\n └── C@1.0.0\\n\"\n              })\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"只要 package.json 有變更，本地需要刪除 node_modules 重新 install，否則可能會導致生產環境與開發環境 node_modules 結構不同，代碼無法正常運行。\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"yarn\",\n      children: \"Yarn\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"為了解決 npm v3 的 dependencies 安裝速度慢和 non-determinism (不確定性)。針對前者，yarn 採用了 asynchronous 的方式來安裝\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-4\",\n          id: \"user-content-fnref-4\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"4\"\n        })\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"為了解決 non-determinism (不確定性)，yarn 發明了 \", _jsx(_components.code, {\n        children: \"yarn.lock\"\n      }), \" 來鎖定 dependencies 版本的功能。lockfile 記錄了專案所有依賴關係的檔案，其中包括了主要依賴、子依賴、版本號、下載網址以及驗證模組完整性的 hash。它能夠保證不論在哪個環境或容器中，通過相同的依賴關係可以得到相同的 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 目錄結構，確保了依賴安裝的穩定性。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"然後，yarn 依然和 npm 一樣是「扁平化」的 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 結構，沒有解決 phantom dependency (幽靈依賴) 和 doppelgangers (多重依賴) 問題。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"小結\",\n      children: \"小結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 npm 和 yarn 所產生的扁平化 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \" 的結構下，雖然解決了依賴地獄、一致性與兼容性的問題，但多 phantom dependency (幽靈依賴) 和 doppelgangers (多重依賴) 並沒有好的解決方式。\\n因為在不考慮循環依賴的情況下，實際的依賴結構圖為有向無環圖 (Directed Acyclic Graph, DAG)\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-5\",\n          id: \"user-content-fnref-5\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"5\"\n        })\n      }), \"，但是 npm 和 yarn 所產生的是有向無環圖\\n的一個超集（多出了很多錯誤祖先節點和兄弟節點之間的鏈接），這導致了很多的問題。pnpm 的出現就是為了更加精確的模擬 DAG 來解決 yarn 和 npm\\n的問題。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"pnpm\",\n      children: \"PNPM\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"pnpm 為了解決扁平化和不必要的 dependencies 複製問題，引入了「內容尋址存儲（Content-addressable storage, CAS）」來管理 modules。該策略不去複製 dependencies，而是通過「硬鏈接（Hard link）\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-6\",\n          id: \"user-content-fnref-6\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"6\"\n        })\n      }), \"」和「符號鏈接（Symbolic link）」的方式。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"Hard link (硬鏈接)：\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"是一種指針，用來指向全局 store 中的特定 dependency。當我們在下載 modules 時，pnpm 會從全局 store 硬連接到虛擬 store (也就是 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 底下的 \", _jsx(_components.code, {\n            children: \".pnpm\"\n          }), \")。如此一來，不同的 modules 就可以共享相同的 dependency，從而節省磁盤空間。\"]\n        }), \"\\n\", _jsx(_components.p, {\n          children: \"例如我們在我們專案底下安裝 modules 時，會出現以下畫面：\"\n        }), \"\\n\", _jsx(\"div\", {\n          style: {\n            marginTop: -120,\n            marginBottom: -120\n          },\n          children: _jsx(_components.p, {\n            children: _jsx(_components.img, {\n              src: \"https://i.imgur.com/j0dGl4R.png?w=700\",\n              alt: \"pnpm-install\"\n            })\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"這裡的意思是 packages 是從全局 store \", _jsx(_components.code, {\n            children: \"/Users/retr0327/Library/pnpm/store/v3\"\n          }), \" 硬連結到虛擬 store (也就是 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 底下的 \", _jsx(_components.code, {\n            children: \".pnpm\"\n          }), \")。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.strong, {\n            children: \"Symbolic link (符號鏈接)：\"\n          })\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"又被稱為「軟連接」，主要是用來解決 dependencies 之間的\", _jsx(_components.strong, {\n            children: \"版本\"\n          }), \"衝突問題。在安裝 modules 時，pnpm 會在該 modules 底下的 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 新建一個文件，內容指向另一個路徑。\"]\n        }), \"\\n\", _jsxs(_components.p, {\n          children: [\"在安裝 dependencies 時，pnpm 會在 \", _jsx(_components.code, {\n            children: \".pnpm\"\n          }), \" 目錄中建立軟連結，並且透過軟連結將 dependencies 連結到指定版本，以確保每個專案中都會使用相同版本的 dependencies。如此一來，就可以在不同版本之間輕鬆地切換，而不會影響其他項目。\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"從官方給的原理圖，可以發現所有的 dependencies 都是從全局 store \", _jsx(_components.strong, {\n        children: \"硬連接\"\n      }), \"到了 \", _jsx(_components.code, {\n        children: \"node_modules/.pnpm\"\n      }), \" 下，然後透過軟連結來相互依賴。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://d33wubrfki0l68.cloudfront.net/64b2f62af3b1c3dc4314df0ec517d9661d03b934/523db/zh-tw/assets/images/node-modules-structure-8ab301ddaed3b7530858b233f5b3be57.jpg?w=1000\",\n        alt: \"pnpm\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"pnpm 解決了幾個重要的問題：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Phantom dependency (幽靈依賴)：\"\n          }), \"\\n安裝的 modules 會平鋪在 \", _jsx(_components.code, {\n            children: \"node_modules\"\n          }), \" 下，sub dependencies 不會被提升，不會產生幽靈依賴。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"Doppelgangers (多重依賴)：\"\n          }), \"\\n相同的依賴只會在全局 store 中安裝一次。項目中的都是源文件的副本，幾乎不佔用任何空間，沒有了依賴分身。\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.strong, {\n            children: \"安裝速度\"\n          }), \"：\\n鏈接的優勢使 pnpm 的安裝速度在大多數場景都比 npm 和 yarn 快 2 倍，節省的磁盤空間也更多\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但 pnpm 也不完全是沒有缺點，如以下：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"因爲 dependencies 是安裝在 store 中，調試依賴或 patch-package 給 dependencies 打補丁也不太方便，可能會影響其他項目。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"pnpm 在 Windows 上可能會受到文件系統限制的影響，因為它使用了硬連結，而 Windows 的 NTFS 文件系統對硬連結的支持有限。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"一開始的 npm v1/v2 利用「嵌套」的方式管理 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \"，但這樣會複製相同的 dependencies 太多次，造成 dependency hell。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"npm v3+ 和 yarn 利用「扁平化」的方式管理 \", _jsx(_components.code, {\n        children: \"node_modules\"\n      }), \"，解決了 dependency hell 但引入了 phantom dependency、doppelganers 等問題。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"pnpm 則是用了另一種方式，不再是複製了，而是都從全局 store 硬連接到 \", _jsx(_components.code, {\n        children: \"node_modules/.pnpm\"\n      }), \"，然後之間通過軟鏈接來組織依賴關係。節省磁盤空間，也沒有幽靈依賴問題，安裝速度也更快。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.readfog.com/a/1673072431709917184\",\n          children: \"深入淺出 npm - yarn - pnpm 包管理機制\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://mp.weixin.qq.com/s/CYQQKvy9MaGHdpSHpBJwzw\",\n          children: \"關於依賴管理的真相— 前端包管理器探究\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://juejin.cn/post/6932046455733485575\",\n          children: \"關於現代包管理器的深度思考——為什麼現在我更推薦 pnpm 而不是 npm/yarn?\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://pnpm.io/motivation\",\n          children: \"PNPM - Motivation\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://zhuanlan.zhihu.com/p/353208988\",\n          children: \"NPM 中的 phatom 與 doppelgangers 問題\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"npm v3 利用「依賴查找算法」，以遞歸的方式向上查找 \", _jsx(_components.code, {\n              children: \"node_modules\"\n            }), \"。在安裝新的 dependencies 時，會不停往上級 \", _jsx(_components.code, {\n              children: \"node_modules\"\n            }), \" 中查找。如果找到相同版本的包就不會重新安裝，在遇到版本衝突時才會在模塊下的 \", _jsx(_components.code, {\n              children: \"node_modules\"\n            }), \" 目錄下存放該模塊子依賴，解決了大量包重複安裝的問題，依賴的層級也不會太深。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-2\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"由於 A 和 B@1.0.0 都在 \", _jsx(_components.code, {\n              children: \"node_modules\"\n            }), \" 的頂層目錄中，在專案中引用 B@1.0.0 也是能正常工作的。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-2\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-3\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"「確定性」指在給定 package.json 下，無論在何種環境下執行 npm install 都能得到相同的 node_modules 目錄結構。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-3\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-4\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"npm v3 以前的安裝任務是 synchronous 的，也就是會等待一個 dependencies 完全安裝，然後再繼續下一個。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-4\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-5\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"有向無環圖 (Directed Acyclic Graph, DAG) 指的是從點出發用有方向的箭頭連接到其他的點構成的整個圖，而且從任意點出發，不會回到自己本身(無環)。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-5\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-6\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"hard link 是指同一個檔案在不同目錄中有多個指向同一個 inode 的檔案名稱，使得多個檔案名稱都指向同一個文件內容。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-6\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},"headings":[{"depth":2,"value":"NPM"},{"depth":3,"value":"v1/v2 - Dependency Hell (依賴地獄)"},{"depth":3,"value":"v3 - Phantom dependency (幽靈依賴)、Doppelgangers (多重依賴)、Non-Determinism (不確定性)"},{"depth":2,"value":"Yarn"},{"depth":2,"value":"小結"},{"depth":2,"value":"PNPM"},{"depth":2,"value":"總結"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-01-28","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"},"siblings":{"next":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"},"prev":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-01-28","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}}},"colorScheme":"light","__N_SSG":true}