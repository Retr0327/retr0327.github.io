{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    pre: \"pre\",\n    strong: \"strong\",\n    sup: \"sup\",\n    a: \"a\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    h4: \"h4\",\n    ol: \"ol\",\n    section: \"section\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"group-by\",\n      children: \"GROUP BY\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"GROUP BY\"\n      }), \" 是一種在 SQL 中常用的功能，它允許我們按照一定的規則將數據進行分組。假設我們有一個 \", _jsx(_components.code, {\n        children: \"engineers\"\n      }), \" table，其結構如下：\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"id\"\n          }), _jsx(_components.th, {\n            children: \"name\"\n          }), _jsx(_components.th, {\n            children: \"language\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"1\"\n          }), _jsx(_components.td, {\n            children: \"Alice\"\n          }), _jsx(_components.td, {\n            children: \"Python\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"2\"\n          }), _jsx(_components.td, {\n            children: \"Bob\"\n          }), _jsx(_components.td, {\n            children: \"Go\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"3\"\n          }), _jsx(_components.td, {\n            children: \"Charlie\"\n          }), _jsx(_components.td, {\n            children: \"C\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"4\"\n          }), _jsx(_components.td, {\n            children: \"Dave\"\n          }), _jsx(_components.td, {\n            children: \"Python\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"5\"\n          }), _jsx(_components.td, {\n            children: \"Eve\"\n          }), _jsx(_components.td, {\n            children: \"TypeScript\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"6\"\n          }), _jsx(_components.td, {\n            children: \"Frank\"\n          }), _jsx(_components.td, {\n            children: \"TypeScript\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"7\"\n          }), _jsx(_components.td, {\n            children: \"Grace\"\n          }), _jsx(_components.td, {\n            children: \"Java\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"8\"\n          }), _jsx(_components.td, {\n            children: \"Heidi\"\n          }), _jsx(_components.td, {\n            children: \"Python\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"假設我們想要統計「每個語言的使用人數」，我們可以用 \", _jsx(_components.code, {\n        children: \"GROUP BY\"\n      }), \" 來達成。以下例子我們以 PostgreSQL 為例：\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-sql\",\n        children: \"SELECT language, COUNT(name) AS \\\"numbers\\\"\\nFROM engineers\\nGROUP BY language;\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這個 SQL query 先將工程師按 \", _jsx(_components.code, {\n        children: \"language\"\n      }), \" 分組，然後對每個分組應用 \", _jsx(_components.code, {\n        children: \"COUNT\"\n      }), \" 函數，計算每個分組的數量。因此，我們會得到以下結果：\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"language\"\n          }), _jsx(_components.th, {\n            children: \"numbers\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Python\"\n          }), _jsx(_components.td, {\n            children: \"3\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Go\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"C\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"TypeScript\"\n          }), _jsx(_components.td, {\n            children: \"2\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Java\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們可以通過這種方式對數據進行分組統計，以便更好地了解數據分佈和分類情況。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"group-by-原理分析\",\n      children: \"GROUP BY 原理分析\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"當 \", _jsx(_components.code, {\n        children: \"GROUP BY\"\n      }), \" 在執行數據分組時，會使用一個 temporary table\\n(臨時表) 來存儲每個分組的數據。分組後，我們可以對每組數據進行各種聚合（aggregate）操作，例如 \", _jsx(_components.code, {\n        children: \"SUM\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"AVG\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"COUNT\"\n      }), \"\\n等。這個過程可以看作是「\", _jsx(_components.strong, {\n        children: \"化整為零策略（split-apply-combine）\"\n      }), \"」\", _jsx(_components.sup, {\n        children: _jsx(_components.a, {\n          href: \"#user-content-fn-1\",\n          id: \"user-content-fnref-1\",\n          \"data-footnote-ref\": true,\n          \"aria-describedby\": \"footnote-label\",\n          children: \"1\"\n        })\n      }), \"的一個具體實現，流程如下：\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://i.imgur.com/nxXoTuQ.png?w=800&pt=60&pb=60\",\n        alt: \"Imgur\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Split\"\n        }), \"：根據 \", _jsx(_components.code, {\n          children: \"FROM \\\\<table-name\\\\> GROUP BY \\\\<column-name\\\\>\"\n        }), \"，將每個分組的數據存儲到臨時表中。\", _jsx(_components.sup, {\n          children: _jsx(_components.a, {\n            href: \"#user-content-fn-2\",\n            id: \"user-content-fnref-2\",\n            \"data-footnote-ref\": true,\n            \"aria-describedby\": \"footnote-label\",\n            children: \"2\"\n          })\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Apply\"\n        }), \"：根據 \", _jsx(_components.code, {\n          children: \"SELECT \\\\<column-name\\\\>\"\n        }), \"，對每個分組的數據進行聚合操作。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Combine\"\n        }), \"：將聚合結果返回。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"以下我們以 \", _jsx(_components.code, {\n        children: \"engineers\"\n      }), \" table 為例，來了解 \", _jsx(_components.code, {\n        children: \"GROUP BY\"\n      }), \" 的具體運行原理。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"split\",\n      children: \"Split\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"FROM engineers GROUP BY language\"\n      }), \" 在被執行後，生成了一個 temporary table，如下所示：\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"id\"\n          }), _jsx(_components.th, {\n            children: \"name\"\n          }), _jsx(_components.th, {\n            children: \"language\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsxs(_components.td, {\n            children: [\"1\", _jsx(\"br\", {}), \"4\", _jsx(\"br\", {}), \"8\"]\n          }), _jsxs(_components.td, {\n            children: [\"Alice\", _jsx(\"br\", {}), \"Dave\", _jsx(\"br\", {}), \"Heidi\"]\n          }), _jsx(_components.td, {\n            children: \"Python\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"2\"\n          }), _jsx(_components.td, {\n            children: \"Bob\"\n          }), _jsx(_components.td, {\n            children: \"Go\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"3\"\n          }), _jsx(_components.td, {\n            children: \"Charlie\"\n          }), _jsx(_components.td, {\n            children: \"C\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsxs(_components.td, {\n            children: [\"5\", _jsx(\"br\", {}), \"6\"]\n          }), _jsxs(_components.td, {\n            children: [\"Eve\", _jsx(\"br\", {}), \"Frank\"]\n          }), _jsx(_components.td, {\n            children: \"TypeScript\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"7\"\n          }), _jsx(_components.td, {\n            children: \"Grace\"\n          }), _jsx(_components.td, {\n            children: \"Java\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"GROUP BY language\"\n      }), \" 會先找到 \", _jsx(_components.code, {\n        children: \"language\"\n      }), \" 這個欄位，然後將具有「相同 language」的值分組，並合併成一行（將所有 id 和 name\\n寫到一個單元格中）。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"apply\",\n      children: \"Apply\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在第二階段會對每個子及應用一個「聚合函數 (aggregate functions)」，然後將結果組合起來。但不知道你有沒以想過為何要用聚合函數 (aggregate functions)？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"原因在於像 PostgreSQL 這樣的 RDBMS (Relational Database Management System)\\n是基於「關係」的，也就是一個單元格位「\", _jsx(_components.strong, {\n        children: \"不允許有多個值\"\n      }), \"」。舉例來說，如果我們執行 \", _jsx(_components.code, {\n        children: \"SELECT * FROM engineers GROUP BY language\"\n      }), \" 會得到\\ntemporary table 的結果：\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"id\"\n          }), _jsx(_components.th, {\n            children: \"name\"\n          }), _jsx(_components.th, {\n            children: \"language\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsxs(_components.td, {\n            children: [\"1\", _jsx(\"br\", {}), \"4\", _jsx(\"br\", {}), \"8\"]\n          }), _jsxs(_components.td, {\n            children: [\"Alice\", _jsx(\"br\", {}), \"Dave\", _jsx(\"br\", {}), \"Heidi\"]\n          }), _jsx(_components.td, {\n            children: \"Python\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"2\"\n          }), _jsx(_components.td, {\n            children: \"Bob\"\n          }), _jsx(_components.td, {\n            children: \"Go\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"3\"\n          }), _jsx(_components.td, {\n            children: \"Charlie\"\n          }), _jsx(_components.td, {\n            children: \"C\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsxs(_components.td, {\n            children: [\"5\", _jsx(\"br\", {}), \"6\"]\n          }), _jsxs(_components.td, {\n            children: [\"Eve\", _jsx(\"br\", {}), \"Frank\"]\n          }), _jsx(_components.td, {\n            children: \"TypeScript\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"7\"\n          }), _jsx(_components.td, {\n            children: \"Grace\"\n          }), _jsx(_components.td, {\n            children: \"Java\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但由於 RDBMS，不允許一個單元格有多個值，執行 \", _jsx(_components.code, {\n        children: \"SELECT *\"\n      }), \" 後就會報錯。因此，我們必須將每個分組的數據\", _jsx(_components.strong, {\n        children: \"進行聚合\"\n      }), \"，因為聚合函數\\n(aggregate functions) 的功能就是用來輸入多個數據並輸出一個數據的。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"combine\",\n      children: \"Combine\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"選定好要使用哪種聚合函數 (aggregate functions) 後，我們就可以將聚合結果組合起來，並返回結果。在我們之前的例子中，我們使用 \", _jsx(_components.code, {\n        children: \"COUNT\"\n      }), \"\\n函數，來計算每個 \", _jsx(_components.code, {\n        children: \"language\"\n      }), \" 的使用人數，因此得到以下結果：\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"language\"\n          }), _jsx(_components.th, {\n            children: \"numbers\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Python\"\n          }), _jsx(_components.td, {\n            children: \"3\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Go\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"C\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"TypeScript\"\n          }), _jsx(_components.td, {\n            children: \"2\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"Java\"\n          }), _jsx(_components.td, {\n            children: \"1\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://juejin.cn/post/7053966777088213005#heading-13\",\n          children: \"看一遍就理解：group by 詳解\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=SI-bPx4jaGc\",\n          children: \"PostgreSQL: Group By | Course | 2019\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.section, {\n      \"data-footnotes\": true,\n      className: \"footnotes\",\n      children: [_jsx(_components.h2, {\n        className: \"sr-only\",\n        id: \"footnote-label\",\n        children: \"Footnotes\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-1\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"Split-apply-combine 指的是將數據集拆分成多個子集，對每個子集應用一個函數，然後將結果組合起來。在 SQL 中，GROUP BY 拆分數據集，並用聚合函數（aggregate functions）對每個子集進行計算，然後將結果合併起來。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-1\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          id: \"user-content-fn-2\",\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"之所以先執行 \", _jsx(_components.code, {\n              children: \"FROM \\\\<table-name\\\\> GROUP BY \\\\<column-name\\\\>\"\n            }), \" 是因為 sql 的 order of operations (執行順序) 有關，詳情請參考 \", _jsx(_components.a, {\n              href: \"https://www.thedataschool.co.uk/eamonn-woodham/sql-order-of-operations\",\n              children: \"SQL order of operations\"\n            }), \"。 \", _jsx(_components.a, {\n              href: \"#user-content-fnref-2\",\n              \"data-footnote-backref\": true,\n              className: \"data-footnote-backref\",\n              \"aria-label\": \"Back to content\",\n              children: \"↩\"\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"理解 GROUP BY","createdAt":"2023-04-16","excerpt":"之前在紀錄 ORM 時有提到為了避免 N+1，可以用 GROUP BY 來避免。因為 GROUP BY 很常在 SQL 中使用，所以是應該好好記下來才行。","slug":"/blog/p/sql-group-by","category":["sql"],"coverImage":"https://www.aviator.co/blog/wp-content/uploads/2023/03/postgres-logo-1024x576.png"}},"headings":[{"depth":2,"value":"GROUP BY"},{"depth":2,"value":"GROUP BY 原理分析"},{"depth":3,"value":"Split"},{"depth":3,"value":"Apply"},{"depth":3,"value":"Combine"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"理解 GROUP BY","createdAt":"2023-04-16","excerpt":"之前在紀錄 ORM 時有提到為了避免 N+1，可以用 GROUP BY 來避免。因為 GROUP BY 很常在 SQL 中使用，所以是應該好好記下來才行。","slug":"/blog/p/sql-group-by","category":["sql"],"coverImage":"https://www.aviator.co/blog/wp-content/uploads/2023/03/postgres-logo-1024x576.png"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["sql"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://i.imgur.com/aAe4oVE.png"}}],"frontMatter":{"title":"理解 GROUP BY","createdAt":"2023-04-16","excerpt":"之前在紀錄 ORM 時有提到為了避免 N+1，可以用 GROUP BY 來避免。因為 GROUP BY 很常在 SQL 中使用，所以是應該好好記下來才行。","slug":"/blog/p/sql-group-by","category":["sql"],"coverImage":"https://www.aviator.co/blog/wp-content/uploads/2023/03/postgres-logo-1024x576.png"},"siblings":{"next":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"},"prev":null}},"colorScheme":"light","__N_SSG":true}