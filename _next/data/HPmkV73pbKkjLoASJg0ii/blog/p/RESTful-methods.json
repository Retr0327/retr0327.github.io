{"pageProps":{"post":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    strong: \"strong\",\n    h3: \"h3\",\n    pre: \"pre\",\n    code: \"code\",\n    blockquote: \"blockquote\",\n    del: \"del\",\n    a: \"a\",\n    h4: \"h4\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"不知道大家是不是跟我一樣，在一開始學 RESTful 架構時，總是認為以下幾個 HTTP request methods 就是對應 CRUD：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"POST → create\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"GET → read\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PUT → update\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DELETE → delete\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但開發時間久了，我發現自己會過度拘泥於語意，導致自己的程式變得沒有那麼 RESTful。後來我才知道，自己的對 HTTP request\\nmethods 的理解一直有誤，因為我沒有把 method properties (方法屬性) 給納入考量。舉例來說，我在做使用者更新時，總是用\\nPUT 的方式去更新 database，但如果根據 idempotent 來去思考，會發現 PATCH 更適合而不是\\nPUT，是因為 PUT 要求我們提供整個資源的內容，而不是部分。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"method-properties-方法屬性\",\n      children: \"Method Properties (方法屬性)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Method properties (方法屬性) 是指每個 HTTP verbs 的特性，像是他們的語意、安全與否、是否 idempotent (幂等) 或可不可以\\ncache。這些屬性之所以重要是因為它們決定了每個 verbs 如何被使用。\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"Verb\"\n          }), _jsx(_components.th, {\n            children: \"Safe\"\n          }), _jsx(_components.th, {\n            children: \"Idempotent\"\n          }), _jsx(_components.th, {\n            children: \"Cacheable\"\n          }), _jsx(_components.th, {\n            children: \"Action\"\n          }), _jsx(_components.th, {\n            children: \"Semantics\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"GET\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"讀取\"\n          }), _jsx(_components.td, {\n            children: \"請求所需要的資源\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"HEAD\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"讀取\"\n          }), _jsx(_components.td, {\n            children: \"與 GET 相同，但沒有 response body\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"POST\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"新增\"\n          }), _jsx(_components.td, {\n            children: \"request 帶上 payload，執行特定資源處理\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PATCH\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"部分\"\n            }), \"更新\"]\n          }), _jsx(_components.td, {\n            children: \"request 帶上 payload，更新部分內容\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PUT\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsxs(_components.td, {\n            children: [_jsx(_components.strong, {\n              children: \"完整\"\n            }), \"更新\"]\n          }), _jsx(_components.td, {\n            children: \"request 帶上 payload，更全部分內容\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"DELETE\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"O\"\n          }), _jsx(_components.td, {\n            children: \"X\"\n          }), _jsx(_components.td, {\n            children: \"刪除\"\n          }), _jsx(_components.td, {\n            children: \"刪除資源\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"safe-method-安全方法\",\n      children: \"Safe Method (安全方法)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其實講的是在請求的過程中，是否有任何資源被改動。如果沒有，那就是\\nsafe；反之，有改動則為 unsafe：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"safe：GET、HEAD\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"unsafe：POST、PUT、DELETE\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"之所以要規範 safe 和 unsafe 是為了要避免像是網頁爬蟲或是預先載入（pre-fetching）的執行，不小觸發了 unsafe\\nmethods。假設你的 URL 長這樣：\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-url\",\n        children: \"https://example.com?article=2&action=delete\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那可能在經過 Google 的爬蟲後，整個文章都直接被刪除了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"idempotent-method-冪等方法\",\n      children: \"Idempotent Method (冪等方法)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了第一次，不管請求被執行了 n 次，所回傳的結果都是相同的：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"idempotent：GET、HEAD、PUT、DELETE\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"non-idempotent：POST、PATCH\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"[Triton Ho from 真 . 淺談 RESTful API]雖然原始 HTTP POST 定義是 non-idempotent，但是他沒禁止你自行解決 idempotent 問題\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"之所以要區分 idempotent 和 non-idempotent 是因為我們不能永遠保證網路的可靠性 \", _jsx(_components.del, {\n        children: \"(一整個\\nCAP 理論的既視感)\"\n      }), \"，如果 client 端使用 non-idempotent\\n的話可能會不小心刪除多個資源或建立多個副本。相較之下，如果使用 idempotent 的方法，client\\n則可以隨心所欲地重試請求。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 Triton Ho 大神的 \", _jsx(_components.a, {\n        href: \"https://github.com/TritonHo/slides/blob/master/Taipei%202015-11%20talk/RESTful%20API%20Design-tw-2.0.pdf\",\n        children: \"真 . 淺談 RESTful API\"\n      }), \"\\n有提到說是否 idempotent 是看我們怎麼去做改動的，以 PATCH 為例：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"idempotent：SET Age = 31\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"non-idempotent：SET Age = Age + 1\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"cacheable-method-可快取方法\",\n      children: \"Cacheable Method (可快取方法)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"指的是可以被 cache 的 HTTP request methods，也就是 GET、HEAD 和 POST。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"參考資料\",\n      children: \"參考資料\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/TritonHo/slides/blob/master/Taipei%202015-11%20talk/RESTful%20API%20Design-tw-2.0.pdf\",\n          children: \"真 . 淺談 RESTful API\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://ihower.tw/blog/archives/6483#comments\",\n          children: \"HTTP Verbs: 談 POST, PUT 和 PATCH 的應用\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://notfalse.net/43/http-request-method#-Method-Properties\",\n          children: \"HTTP 請求方法 (Request Method)\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"}},"headings":[{"depth":2,"value":"Method Properties (方法屬性)"},{"depth":3,"value":"Safe Method (安全方法)"},{"depth":3,"value":"Idempotent Method (冪等方法)"},{"depth":3,"value":"Cacheable Method (可快取方法)"},{"depth":3,"value":"參考資料"}]},"posts":[{"frontMatter":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"}},{"frontMatter":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://cdn.educba.com/academy/wp-content/uploads/2020/01/Process-vs-Thread.jpg.webp"}},{"frontMatter":{"title":"Dependency Inversion Principle & Dependency Injection","createdAt":"2023-01-26","updatedAt":"2023-02-13","excerpt":"這篇想要記錄的是我在學 design patterns (設計模式) 的過程時，常常分不清 dependency injection 和 dependency inversion 之間的關係。因此借機寫成一個 blog，幫自己重新了解一次。","slug":"/blog/p/dip-and-di","category":["design pattern"],"coverImage":"https://stackify.com/wp-content/uploads/2018/06/Design-Patterns-Explained-%E2%80%93-Dependency-Injection-with-Code-Examples.png"}},{"frontMatter":{"title":"ORM 基礎觀念","createdAt":"2023-02-07","updatedAt":"2023-02-13","excerpt":"很常在後端開發使用 ORM (Object-Relational Mapping) 來處理 database，但卻沒有清楚為何該使用它，只知道很多人推薦，於是打算好好紀錄一番。","slug":"/blog/p/orm","category":["database"],"coverImage":"https://miro.medium.com/max/1200/1*Tz54hHWz7O2nWu5AeajVWQ.png"}},{"frontMatter":{"title":"Encoding、Encryption 及 Hashing","createdAt":"2023-02-05","updatedAt":"2023-02-06","excerpt":"很常在後端開發使用 encoding (編碼)、encryption (加密) 和 hashing (雜湊)，但卻傻傻分不清他們的關係，於是打算好好紀錄一番。","slug":"/blog/p/encode-encrypt-hash","category":["security","cryptography"],"coverImage":"https://sectigostore.com/blog/wp-content/uploads/2019/09/HashingvsEncryption-lr-940x529.jpg"}},{"frontMatter":{"title":"ACID 基礎觀念","createdAt":"2023-01-29","updatedAt":"2023-02-05","excerpt":"這篇想要紀錄的是在學關聯式資料庫（Relational Database Management System, RDDMS）或是面試中很常會碰到的專有名詞 —— ACID。","slug":"/blog/p/acid","category":["RDBMS","database"],"coverImage":"https://clockwise.software/img/blog/relational-vs-non-relational-databases-advantages-and-disadvantages/header-background.jpg"}},{"frontMatter":{"title":"npm vs. yarn vs. pnpm","createdAt":"2023-01-24","excerpt":"這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。","slug":"/blog/p/pnpm","category":["pnpm","nodeJs"],"coverImage":"https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67"}},{"frontMatter":{"title":"孤獨的程式廢人 - Why Have a Blog?","createdAt":"2023-01-21","updatedAt":"2023-01-23","excerpt":"這篇講述了筆者為何突然在某個深夜突然想要重啟自己多年想要寫 blog 的計畫，礙於當時啥都不會只能套用別人的模板，導致無法做出自己想要的樣子。3 年後，且在參與多項計畫後，將帶著所學到的技術嘗試重返最初的感動。","slug":"/blog/p/hello-world","category":["experience","blog"],"coverImage":"https://blog.logrocket.com/wp-content/uploads/2022/03/create-next-js-mdx-blog.png"}}],"frontMatter":{"title":"關於 HTTP Request Method 的方法屬性","createdAt":"2023-02-13","updatedAt":"2023-02-14","excerpt":"一直以來我都只認為自己知道何時該用什麼樣的 HTTP request methods，但詳細去了解他們的屬性後，才發現自己漏掉很多很重要的基本知識。","slug":"/blog/p/RESTful-methods","category":["HTTP","RESTful"],"coverImage":"https://www.openprogrammer.info/wp-content/uploads/2015/01/restful.gif"},"siblings":{"next":{"title":"嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)","createdAt":"2023-02-14","excerpt":"在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。","slug":"/blog/p/process-thread-coroutine","category":["OS"],"coverImage":"https://cdn.educba.com/academy/wp-content/uploads/2020/01/Process-vs-Thread.jpg.webp"},"prev":null}},"colorScheme":"light","__N_SSG":true}