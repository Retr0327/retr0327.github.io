---
title: npm vs. yarn vs. pnpm
createdAt: '2023-01-24'
excerpt: 這篇紀錄了關於 JavaScript modules 管理工具 npm、yarn、pnpm 的歷史關係及原理。
slug: '/blog/p/pnpm'
category: ['pnpm', 'nodeJs']
coverImage: 'https://camo.githubusercontent.com/15249b13cd482f77ff1e9f74952f1a01892912af0c5cab22f73f26d595b2f0bf/68747470733a2f2f692e696d6775722e636f6d2f716c57316545472e706e67'
---

## NPM

雖然 npm 允許開發人員可以輕鬆地管理和安裝 node modules。但是，它也有一些缺點，我們分成兩大時期來看：

### v1/v2 - Dependency Hell (依賴地獄)

npm v1/v2 是使用了相對簡單的「嵌套式」`node_modules` 結構，也就是 dependencies (依賴) 還會有自己的 dependencies。
設想一個情境，我們安裝了 A 和 C modules，而 A 和 C 剛好依賴不同版本的 B modules。這時候的 node_modules 會是這樣：

```bash
node_modules
├── A@1.0.0
│   └── node_modules
│       └── B@1.0.0
└── C@1.0.0
    └── node_modules
        └── B@2.0.0
```

如果後來新增的 D 也是依賴 B@1.0.0，此時生成的 `node_modules` 目錄便會如下所示：

```bash
node_modules
├── A@1.0.0
│   └── node_modules
│       └── B@1.0.0
├── C@1.0.0
│   └── node_modules
│       └── B@2.0.0
└── D@1.0.0
    └── node_modules
        └── B@1.0.0
```

可以看到 B@1.0.0 重複安裝了兩遍，造成不必要的空間浪費，這就是「依賴地獄（Dependency Hell）」。

![dependency-hell](https://preview.redd.it/tfugj4n3l6ez.png?auto=webp&s=b8163176d8482d5e78ac631e16b7973a52e3b188)

### v3 - Phantom dependency (幽靈依賴)、Doppelgangers (多重依賴)、Non-Determinism (不確定性)

為了解決 dependency hell 的問題，npm v3 採用了「扁平化」設計[^1]，將所有 dependencies 安裝在 `node_modules` 的頂層目錄下，而不是在各自的子目錄中。

```bash
node_modules
├── A@1.0.0
├── B@1.0.0
└── C@1.0.0
    └── node_modules
        └── B@2.0.0
├── D@1.0.0
```

可以看到 A 和 D 的子依賴的 B@1.0.0 不再放在他們各自底下的 `node_modules`，而是與他們同層級，而 C 依賴的 B@2.0.0
則因爲版本原因還是嵌套在 C 的 `node_modules` 下。扁平化的模式解決了依賴地獄的問題，但也帶來了額外的新問題。

[^1]: npm v3 利用「依賴查找算法」，以遞歸的方式向上查找 `node_modules`。在安裝新的 dependencies 時，會不停往上級 `node_modules` 中查找。如果找到相同版本的包就不會重新安裝，在遇到版本衝突時才會在模塊下的 `node_modules` 目錄下存放該模塊子依賴，解決了大量包重複安裝的問題，依賴的層級也不會太深。

- **Phantom dependency (幽靈依賴)**

  雖然我們只安裝 A、C 和 D，但因為 npm v3 的特性也會將 B@1.0.0 **平鋪**到 `node_modules` 下[^2]，

  ```bash
  {
      "dependencies": {
          "A": "^1.0.0",
          "C": "^1.0.0"
      }
  }
  ```

  但這樣會導致意想不到的問題，例如某天 A 不在依賴 B 或是 B 的版本更新了，那麼就會造成依賴缺失或兼容性問題，導致專案在運行時會立刻報錯。

[^2]: 由於 A 和 B@1.0.0 都在 `node_modules` 的頂層目錄中，在專案中引用 B@1.0.0 也是能正常工作的。

- **Doppelgangers (多重依賴)**
  假設我們新安裝一個依賴 B@2.0.0 的 E：

  | B@1.0.0 | B@2.0.0 |
  | ------- | ------- |
  | A、D    | C、E    |

  <br />

  ```bash
   node_modules
    ├── A@1.0.0
    ├── B@1.0.0
    ├── D@1.0.0
    ├── C@1.0.0
    │   └── node_modules
    │       └── B@2.0.0
    └── E@1.0.0
        └── node_modules
            └── B@2.0.0
  ```

  可以看到 B@2.0.0 被安裝了 2 次。無論是讓 B@1.0.0 還是 B@2.0.0 提升放到 `node_modules` 的頂層，都會使另一個版本重複存在。這樣可能會產
  生一些問題，像是版本重複可能會導致全局的 types 命名出現衝突，雖然各個 package 的代碼不會相互污染，但是他們的 types 仍然可以相互影響。

- **Non-Determinism (不確定性)**[^3]

  npm v3 會導致 node_modules 目錄結構不一定在每一次的下載後都是一致的，目錄及依賴樹結構會取決於開發者的「安裝的順序」。例如在 A 依賴 B@1.0.0，C 依賴 B@2.0.0 的情境中
  ，安裝後究竟應該提升 B 的 1.0.0 還是 2.0.0 到 `node_modules` 的頂層？

  - 情境 1

    ```bash
    node_modules
     ├── A@1.0.0
     ├── B@1.0.0
     └── C@1.0.0
        └── node_modules
          └── B@2.0.0
    ```

  - 情境 2

    ```bash
    node_modules
     ├── A@1.0.0
     │   └── node_modules
     │      └── B@1.0.0
     ├── B@2.0.0
     └── C@1.0.0
    ```

  只要 package.json 有變更，本地需要刪除 node_modules 重新 install，否則可能會導致生產環境與開發環境 node_modules 結構不同，代碼無法正常運行。

[^3]: 「確定性」指在給定 package.json 下，無論在何種環境下執行 npm install 都能得到相同的 node_modules 目錄結構。

## Yarn

為了解決 npm v3 的 dependencies 安裝速度慢和 non-determinism (不確定性)。針對前者，yarn 採用了 asynchronous 的方式來安裝[^4]。

為了解決 non-determinism (不確定性)，yarn 發明了 `yarn.lock` 來鎖定 dependencies 版本的功能。lockfile 記錄了專案所有依賴關係的檔案，其中包括了主要依賴、子依賴、版本號、下載網址以及驗證模組完整性的 hash。它能夠保證不論在哪個環境或容器中，通過相同的依賴關係可以得到相同的 `node_modules` 目錄結構，確保了依賴安裝的穩定性。

[^4]: npm v3 以前的安裝任務是 synchronous 的，也就是會等待一個 dependencies 完全安裝，然後再繼續下一個。

然後，yarn 依然和 npm 一樣是「扁平化」的 `node_modules` 結構，沒有解決 phantom dependency (幽靈依賴) 和 doppelgangers (多重依賴) 問題。

## 小結

在 npm 和 yarn 所產生的扁平化 `node_modules` 的結構下，雖然解決了依賴地獄、一致性與兼容性的問題，但多 phantom dependency (幽靈依賴) 和 doppelgangers (多重依賴) 並沒有好的解決方式。
因為在不考慮循環依賴的情況下，實際的依賴結構圖為有向無環圖 (Directed Acyclic Graph, DAG)[^5]，但是 npm 和 yarn 所產生的是有向無環圖
的一個超集（多出了很多錯誤祖先節點和兄弟節點之間的鏈接），這導致了很多的問題。pnpm 的出現就是為了更加精確的模擬 DAG 來解決 yarn 和 npm
的問題。

[^5]: 有向無環圖 (Directed Acyclic Graph, DAG) 指的是從點出發用有方向的箭頭連接到其他的點構成的整個圖，而且從任意點出發，不會回到自己本身(無環)。

## PNPM

pnpm 為了解決扁平化和不必要的 dependencies 複製問題，引入了「內容尋址存儲（Content-addressable storage, CAS）」來管理 modules。該策略不去複製 dependencies，而是通過「硬鏈接（Hard link）[^6]」和「符號鏈接（Symbolic link）」的方式。

[^6]:hard link 是指同一個檔案在不同目錄中有多個指向同一個 inode 的檔案名稱，使得多個檔案名稱都指向同一個文件內容。

- **Hard link (硬鏈接)：**

  是一種指針，用來指向全局 store 中的特定 dependency。當我們在下載 modules 時，pnpm 會從全局 store 硬連接到虛擬 store (也就是 `node_modules` 底下的 `.pnpm`)。如此一來，不同的 modules 就可以共享相同的 dependency，從而節省磁盤空間。

  例如我們在我們專案底下安裝 modules 時，會出現以下畫面：

  <div style={{ marginTop: -120, marginBottom: -120 }}>
    ![pnpm-install](https://i.imgur.com/j0dGl4R.png?w=700)
  </div>

  這裡的意思是 packages 是從全局 store `/Users/retr0327/Library/pnpm/store/v3` 硬連結到虛擬 store (也就是 `node_modules` 底下的 `.pnpm`)。

- **Symbolic link (符號鏈接)：**

  又被稱為「軟連接」，主要是用來解決 dependencies 之間的**版本**衝突問題。在安裝 modules 時，pnpm 會在該 modules 底下的 `node_modules` 新建一個文件，內容指向另一個路徑。

  在安裝 dependencies 時，pnpm 會在 `.pnpm` 目錄中建立軟連結，並且透過軟連結將 dependencies 連結到指定版本，以確保每個專案中都會使用相同版本的 dependencies。如此一來，就可以在不同版本之間輕鬆地切換，而不會影響其他項目。

從官方給的原理圖，可以發現所有的 dependencies 都是從全局 store **硬連接**到了 `node_modules/.pnpm` 下，然後透過軟連結來相互依賴。

![pnpm](https://d33wubrfki0l68.cloudfront.net/64b2f62af3b1c3dc4314df0ec517d9661d03b934/523db/zh-tw/assets/images/node-modules-structure-8ab301ddaed3b7530858b233f5b3be57.jpg?w=1000)

pnpm 解決了幾個重要的問題：

- **Phantom dependency (幽靈依賴)：**
  安裝的 modules 會平鋪在 `node_modules` 下，sub dependencies 不會被提升，不會產生幽靈依賴。

- **Doppelgangers (多重依賴)：**
  相同的依賴只會在全局 store 中安裝一次。項目中的都是源文件的副本，幾乎不佔用任何空間，沒有了依賴分身。

- **安裝速度**：
  鏈接的優勢使 pnpm 的安裝速度在大多數場景都比 npm 和 yarn 快 2 倍，節省的磁盤空間也更多

但 pnpm 也不完全是沒有缺點，如以下：

- 因爲 dependencies 是安裝在 store 中，調試依賴或 patch-package 給 dependencies 打補丁也不太方便，可能會影響其他項目。
- pnpm 在 Windows 上可能會受到文件系統限制的影響，因為它使用了硬連結，而 Windows 的 NTFS 文件系統對硬連結的支持有限。

## 總結

一開始的 npm v1/v2 利用「嵌套」的方式管理 `node_modules`，但這樣會複製相同的 dependencies 太多次，造成 dependency hell。

npm v3+ 和 yarn 利用「扁平化」的方式管理 `node_modules`，解決了 dependency hell 但引入了 phantom dependency、doppelganers 等問題。

pnpm 則是用了另一種方式，不再是複製了，而是都從全局 store 硬連接到 `node_modules/.pnpm`，然後之間通過軟鏈接來組織依賴關係。節省磁盤空間，也沒有幽靈依賴問題，安裝速度也更快。


#### 參考資料
