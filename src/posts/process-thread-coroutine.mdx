---
title: 嘗試理解 Process (進程)、Thread (線程) 和 Coroutine (協程)
createdAt: '2023-02-14'
excerpt: 在 Python 中我很喜歡用 asyncio 來加快效能，但學得越深就發現除了 asyncio 以外，還有其他如 process、thread 等專業知識是我沒有好好深入了解的，因此想說來好好記錄一番。
slug: '/blog/p/process-thread-coroutine'
category: ['OS']
coverImage: 'https://cdn.educba.com/academy/wp-content/uploads/2020/01/Process-vs-Thread.jpg.webp'
---

網路上有一張圖就可以讓我們快速明白他們之間的差別：

![summary](https://blog.kennycoder.io/2020/05/16/%E9%80%B2%E7%A8%8B-Process-%E3%80%81%E7%B7%9A%E7%A8%8B-Thread-%E3%80%81%E5%8D%94%E7%A8%8B-Coroutine-%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AC%9B%E8%A7%A3/cover.png?pt=25)

## Process (進程)

指的是在 OS (Operating System) 上執行的一個基本單位[^1]，當執行一個 program/application 時，OS 會分配記憶體和
CPU 資源給該 program/application。當我們打開 mac 的 Activity Monitor (活動監控) 或 windows
的工作管理員，就可以看多很多 processes：

![process-mac](https://i.imgur.com/r1x96fi.png?w=800)

[^1]: 實際上一個 CPU 在執行時只能同時運用一個 process，只是 CPU 可以快速地在多個 processes 之間進行切換，使多個 process 模擬同時執行的情況

每次執行程式時，系統都會創建一個新的 process，它代表著程式正在運行的狀態，並且「不會影響其他程式的運行」（如果可以任意呼叫其他應用程式的內容，可能會爆炸吧），也因此他有以下優缺點：

1. 優點：

   - 每個 process 都擁有獨立的系統資源，且不容易相互影響
   - 因為獨立，所以不用作 locking 機制

2. 缺點：建立和 context switching (上下文交換) [^2]的 overhead 較大，因為涉及到 OS 資源的切換

[^2]:
    Context switching (上下文交換) 是指在執行多個 tasks 時，切換不同 tasks 的狀態信息。當 CPU 需要切換到另一個 task
    時，它必須保存當前正在運行的 task 的狀態（例如記憶體位置），並且加載下一個要執行的 task 的狀態

## Thread (線程)

![sd](https://microcontrollerslab.com/wp-content/uploads/2019/08/process-and-program.png?pt=6&pb=70&w=450)

又稱「light weight process」，為 process 內部的執行單元，也就是說一個 process 由至少一個 thread
所組成的。與 process 不一樣的地方在於，由於 threads 彼此之間共享 process 的記憶體空間和其他資源（不是獨立擁有），因此
thread 在做 context switching 時的 overhead 比 process 還要小。

## Parallelism (並行) vs. Concurrency (並發)

![parallelism vs. concurrency](https://www.dotnetcurry.com/images/dotnetcore/concurrent/parallel-vs-concurrent-dotnet-core.png?pt=105&pb=50)

由圖可知，Concurrency 其實就是在多個 tasks 共用「同一個 CPU」時，每個 task 輪流使用該 CPU 的資源，也就是在某個時間點，只會有一個
task 在 CPU 上執行；而 Parallelism 是指多個 CPU 同時執行各自的任務，且不需要 context switching，因此不會出現多個任務搶佔同個
CPU 的情況。

> 如果電腦只有單核，就只能做到 Concurrency。

由於現在的電腦大多都配備多核心，所以才可以達到 parallel，讓我們感受到電腦速度比以往來得快上許多。

## Coroutine (協程)

作為一種「輕量級」[^3]的線程，一個 thread 可以存在多個 coroutines，而 coroutine 也會有自己的 registers、context、stack
等等。與 process 和 thread 不同，coroutine 的調度由「**用戶**」而非 CPU 進行，並且只能進行「非搶佔式」的調度。「非搶佔式調度」是指當一個 coroutine 被 block 住時，將不會影響其他 coroutines 的執行，因此不用像 thread 或 process 要進行搶佔式調度，而是由開發者去控制
coroutine 的切換。如此一來，資源就可以有效地被利用，以達到 concurrency 的概念（因為在同一個 CPU）。以 Python 的 asyncio 為例：

```python
import asyncio

async def coroutine_1():
    print("coroutine 1 started")
    await asyncio.sleep(3)
    print("coroutine 1 finished")

async def coroutine_2():
    print("coroutine 2 started")
    await asyncio.sleep(1)
    print("coroutine 2 finished")

async def main():
    print("main started")
    task1 = asyncio.create_task(coroutine_1())
    task2 = asyncio.create_task(coroutine_2())
    await task1
    await task2
    print("main finished")

asyncio.run(main())

# main started
# coroutine 1 started
# coroutine 2 started
# coroutine 2 finished
# coroutine 1 finished
# main finished
```

當 `coroutine_1` 執行 `await asyncio.sleep(3)` 的時候，它會主動放棄 CPU，等待 3 秒鐘後再繼續執行。在這段時間內，CPU
可以被切換到執行 `coroutine_2`。當 `coroutine_2` 執行 `await asyncio.sleep(1)` 時，它也會主動放棄
CPU，等待 1 秒鐘後再繼續執行。這時 Python 會回到 `coroutine_1` 看它是否已經睡完 3 秒，由於 `coroutine_1` 還沒有睡完
3 秒，所以 Python 又會切換到執行 `coroutine_2`，直到 `coroutine_2` 完成後再回到 `coroutine_1`。當 `coroutine_1`
睡完 3 秒後，Python 會再次切換到 `coroutine_1`，讓它繼續執行，最後再印出 `"coroutine 1 finished"`。

[^3]:
    輕量級一詞來自於 coroutine 相對於 thread 和 process 而言的資源需求較少，特別是在內存消耗、創建/銷毀時間、和 context
    switching 的時間方面

## 總結

|                            | Process   | Thread    | Coroutine  |
| -------------------------- | --------- | --------- | ---------- |
| Resource Utilization       | heavy     | light     | lightest   |
| Scheduling                 | OS-driven | OS-driven | ser-driven |
| Context Switching Overhead | high      | low       | lower      |
| Address Space              | separate  | shared    | shared     |
| Stack Size                 | large     | small     | smaller    |

#### 參考資料

1. [進程 (Process)、線程 (Thread)、協程 (Coroutine) 的概念講解](https://blog.kennycoder.io/2020/05/16/%E9%80%B2%E7%A8%8B-Process-%E3%80%81%E7%B7%9A%E7%A8%8B-Thread-%E3%80%81%E5%8D%94%E7%A8%8B-Coroutine-%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AC%9B%E8%A7%A3/)
2. [Day 18 | Kotlin 中處理異步的好伙伴 - Coroutine](https://ithelp.ithome.com.tw/articles/10239629)
3. [[OS] 作業系統筆記-Process](https://blog.tomchen.me/2020/03/21/OS/%5BOS%5D%20%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%AD%86%E8%A8%98-Process/)
